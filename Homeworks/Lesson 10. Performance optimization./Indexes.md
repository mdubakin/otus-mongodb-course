# Indexes.

### Table of contents:
  - [Задание.](#задание)
  - [Выполнение.](#выполнение)
   
for (i=0; i<1000000; i++) {
  db.users.insertOne(
    {
      "i" : i,
      "username" : "user"+i,
      "age" : Math.floor(Math.random()*120),
      "created" : new Date()
      });
}

# Задание.
```
[] Изучить главу Индексы в книге "Руководство по MongoDB".
[] Вопросы:
  - [] Как выбрать поля для индексирования?
  - [] Зачем и когда нужны составные индексы? 
  - [] Как MongoDB выбирает индекс?
  - [] Что такое обратные индексы?
[] Оптимизация и мониторинг индексов.
[] Изучить метод explain().
[] Поработать с разными видами индексов. 
[] Типы индексов (B-Tree, hash, etc)
[] Hidden indexes.
[] Ограничения (взять из презентации).
```
# Выполнение.

## Вопросы.

### `Как выбрать поля для индексирования?`
Чтобы выбрать, для каких полей создавать индексы, просмотрите ваши частые запросы и запросы, которые должны быть быстрыми, и попробуйте найти общий набор ключей.

### `Зачем и когда нужны составные индексы?`
Составной индекс – это индекс по нескольким полям. Составной индекс полезен, если ваш запрос имеет несколько направлений сортировки или несколько ключей в критериях.

Ставить ключ сортировки первым – это, как правило, хорошая стратегия при разработке составных индексов. Нужно разрабатывать составные индексы таким образом, чтобы поля, для которых вы будете использовать фильтры равенства, предшествовали тем, для которых ваше приложение будет использовать многозначные фильтры.

Пример создания составного индекса:
```js
db.users.createIndex({"age" : 1, "username" : 1})
```

**Схема разработки составного индекса:**
  - ключи для фильтров равенства должны появляться первыми;
  - ключи, используемые для сортировки, должны появляться перед
многозначными полями;
  - ключи для многозначных фильтров должны появляться последни-
ми.

### `Как MongoDB выбирает индекс?`
Предположим, мы получили запрос, и три из пяти наших индексов определены как кандидаты на этот запрос. Затем MongoDB создаст три плана запросов, по одному для каждого из этих индексов, и выполнит запрос в трех параллельных потоках, каждый из которых использует свой индекс.

Визуально можно рассматривать это как гонку, как показано на `рис. 5.1.`
Реальная ценность состязания нескольких планов запросов друг с другом заключается в том, что для последующих запросов, имеющих одинаковую форму запроса, сервер MongoDB будет знать, какой индекс выбрать. Сервер поддерживает кеш планов выполнения запросов. Выигрышный план хранится в кеше для последующего использования для запросов этой формы. Со временем, по мере изменения коллекции и изменения индексов,
в конечном итоге план выполнения запроса может быть удален из кеша, и MongoDB снова будет экспериментировать с возможными планами, чтобы найти тот, который лучше всего подходит для текущей коллекции и набора индексов.

![Рис. 5.1. Как планировщик запросов MongoDB выбирает индекс.](https://i.ibb.co/0mvs3g2/mongodb-5-1.jpg)

### `Что такое обратные индексы?`
Обратные индексы, созданные по ключу -1 и хранящиеся в памяти как отсортированны по убыванию.

Пример:
```js
db.users.createIndex({"age" : 1, "username" : -1})
```
Организация данных об индексе в памяти:
```js
[21, user999600] -> 8765277104
[21, user999407] -> 8765252400
[21, user999390] -> 8765250224
...
[21, user100270] -> 8623545776
[21, user100266] -> 8623545264
[21, user100154] -> 8623530928
...
[30, user100168] -> 8623532720
[30, user100155] -> 8623531056
[30, user100098] -> 8623523760
```
Направление индекса действительно имеет значение только тогда, **когда вы выполняете сортировку по нескольким критериям**. Если вы сортируете только по одному ключу, MongoDB может так же легко прочитать индекс в обратном порядке. Например, если у вас была сортировка по {"age" : -1} и индекс {"age" : 1}, MongoDB мог бы оптимизировать ее так же, как если бы у вас был индекс {"age" : -1 } (поэтому не создавайте оба!). **Направление имеет значение только для сортировок со множеством ключей**.
