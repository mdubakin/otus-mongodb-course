# Aggregation Framework.

### Table of contents:
  - [Задание.](#задание)
  - [Выполнение.](#выполнение)
    - [1. Вопросы.](#1-вопросы)
      - [1.1. Зачем используется агрегация?](#11-зачем-используется-агрегация)
    - [2. Конвейер агрегации.](#2-конвейер-агрегации)
    - [3. Описать работу с этапами агрегации.](#3-описать-работу-с-этапами-агрегации)
      - [3.1. $match.](#31-match)
      - [3.2. $project.](#32-project)
      - [3.3. $limit.](#33-limit)
      - [3.4. $sort.](#34-sort)
      - [3.5. $skip.](#35-skip)
      - [3.6. Углубленное использование этапа $project.](#36-углубленное-использование-этапа-project)
      - [3.7. $unwind.](#37-unwind)
      - [3.8. Работа с массивами.](#38-работа-с-массивами)
        - [3.8.1. $filter.](#381-filter)
        - [3.8.2. $arrayElemAt.](#382-arrayelemat)
        - [3.8.3. $slice.](#383-slice)
        - [3.8.4. $size](#384-size)
      - [3.9. Аккумуляторы и $group.](#39-аккумуляторы-и-group)
        - [3.9.1. $avg.](#391-avg)
        - [3.9.2. $sum.](#392-sum)
      - [3.10. Запись результатов конвейера агрегации в коллекцию.](#310-запись-результатов-конвейера-агрегации-в-коллекцию)

# Задание.
```
[x] Ответить на вопросы:
    - [x] Зачем используется агрегация?
[x] Описать конвейр агрегации.
[] Описать работу с этапами агрегации.
[] Описать популярные аккумуляторы:
    - [x] $avg
    - [x] $sum
    - [] $push
    - [] $first and $last
[x] Описать варианты записи результатов конвейера агрегации в коллекцию.
```
# Выполнение.
-----------------------------------------
## 1. Вопросы.
### 1.1. Зачем используется агрегация?
```
Агрегация используется для анализа данных.
```
-----------------------------------------
## 2. Конвейер агрегации.
```
Конвейер – это массив с документами в качестве элементов.

С помощью конвейера агрегации мы берем входные данные из коллекции MongoDB и пропускаем документы из этой коллекции
через один или несколько этапов, каждый из которых выполняет свою операцию (рис. 7.1). Каждый этап рассматривается
в качестве входных данных, независимо от этапа, прежде чем будут созданы выходные данные.
```
![Конвейер агрегации](https://i.ibb.co/NtcQb4f/photo-2021-12-14-14-22-55.jpg)
```
Отдельным этапом конвейера агрегации является блок обработки данных. Он принимает поток входных документов
по одному за раз, обрабатывает каждый документ по одному за раз и создает выходной поток документов по одному 
за раз (рис. 7.2).
```
![Этапы конвейера агрегации](https://i.ibb.co/Cbp3ptW/image.jpg)
```
Часто нам нужно включить один и тот же тип этапа несколько раз в один конвейер (рис. 7.3).
```
![Повторные этапы в конвейере агрегации](https://i.ibb.co/MVx2JW0/image.jpg)

-----------------------------------------
## 3. Описать работу с этапами агрегации.

### 3.1. $match.
```js
// $match находит и отдает только значения, подходящие условию переданными в этот этап.
//
// Создадим фильтрация по компаниям, основанным в 2004 году.
db.companies.aggregate([
    {$match: { founded_year: 2004 }},
])

// Этап $match эквивалентен простому поиску по findOne:
db.companies.find({ founded_year: 2004 })
```

### 3.2. $project.
```js
// $project получает документ и выводит только те поля, которые указаны со значением 1, и не выводит поля 
// со значением 0.
//
// Уменьшим кол-во выводимых полей с помощью этапа $project. Отключим поле "_id" и оставим только поля 
// "name" и "founded_year".
db.companies.aggregate([
    {$match: { founded_year: 2004 }},
    {$project: {
        _id: 0,
        name: 1,
        founded_year: 1 }
    }
])
```

### 3.3. $limit.
```js
// $limit получает поток документов и отдает определенное кол-во документов дальше по конвейеру.
//
// Здесь мы выводим только названия первых 5-ти компаний используя этап $limit после этапа $match.
db.companies.aggregate([
    {$match: { founded_year: 2004 } },
    {$limit: 5 },
    {$project: {
        _id: 0,
        name: 1 }
    }
])
```

### 3.4. $sort.
```js
// $sort сортирует документы по выбранному полю в порядке возрастания (значение 1) или в порядке
// убывания (значение -1).
//
// Выводим только названия 5 компаний отсортированных по алфавиту (порядку). 
db.companies.aggregate([
    { $match: { founded_year: 2004 } },
    { $sort: { name: 1 } },
    { $limit: 5},
    { $project: {
        _id: 0,
        name: 1}
    }
])
```

### 3.5. $skip.
```js
// $skip получает набор документов, пропускает указанное кол-во первых документов и отдает определенное
// кол-во документов дальше по конвейеру.
//
// Cортируем, затем пропускаем первые 10 документов и снова ограничиваем наш набор результатов 5 документами.
db.companies.aggregate([
    {$match: { founded_year: 2004 } },
    {$sort: { name: 1 } },
    {$skip: 10 },
    {$limit: 5 },
    {$project: {
        _id: 0,
        name: 1 }
    }
])
```

### 3.6. Углубленное использование этапа $project.
```js
// Здесь мы отбираем компании по инвестиционной организации, а затем задаем вывод с помощью этапа $project.
// $ipo.valuation_amount (и др.) означает что нужно взять значение поля вложенного документа или массива.
db.companies.aggregate([
    {$match: { "funding_rounds.investments.financial_org.permalink": "greylock" } },
    {$project: {
        _id: 0,
        name: 1,
        ipo: "$ipo.pub_year",
        valuation: "$ipo.valuation_amount",
        funders: "$funding_rounds.investments.financial_org.permalink"}
    }
]).pretty()
```

### 3.7. $unwind.
```js
// Оператор $unwind берет массив из входного документа и создает выходной документ для каждого элемента 
// в этом массиве (рис. 7.4).
//
// $ipo.valuation_amount (и др.) означает что нужно взять значение поля вложенного документа или массива.
db.companies.aggregate([
    {$match: { "funding_rounds.investments.financial_org.permalink": "greylock" } },
    {$project: {
        _id: 0,
        name: 1,
        ipo: "$ipo.pub_year",
        valuation: "$ipo.valuation_amount",
        funders: "$funding_rounds.investments.financial_org.permalink"}
    }
]).pretty()
```
![Принцип работы оператора $unwind](https://i.ibb.co/s11pB0r/unwind.jpg)

### 3.8. Работа с массивами.

#### 3.8.1. $filter.
```js
// Выражение фильтра выбирает подмножество элементов в массиве на основе критериев фильтра.
//
// Поля $filter: 1. input - указываем массив ($funding_rounds).
// 2. as - указываем имя переменной для каждого из элемента массива.
// 3. cond - условие, если элемент массива проходит его (True), то передается дальше по конвейеру.
db.companies.aggregate([
    { $match: { "funding_rounds.investments.financial_org.permalink": "greylock" } },
    { $project: {
        _id: 0,
        name: 1,
        founded_year: 1,
        rounds: { $filter: {
            input: "$funding_rounds",
            as: "round",
            cond: { $gte: [
                "$$round.raised_amount",
                100000000 ] }
                }
            }
        }
    },
    { $match: { "rounds.investments.financial_org.permalink": "greylock" } },
]).pretty()
```

#### 3.8.2. $arrayElemAt.
```js
// Оператор $arrayElemAt позволяет выбрать элемент в определенной ячейке (индексе) массива.
//
// Первый аргумент указывает на массив. Второй аргумент идентифицирует ячейку в нужном нам массиве.
db.companies.aggregate([
    { $match: { "founded_year": 2010 } },
    { $project: {
        _id: 0,
        name: 1,
        founded_year: 1,
        first_round: { $arrayElemAt: [ "$funding_rounds", 0 ] },
        last_round: { $arrayElemAt: [ "$funding_rounds", -1 ] } }
    }
]).pretty()
```

#### 3.8.3. $slice.
```js
// Оператор $slice позволяет возвращать несколько элементов из массива в последовательности, начиная 
// с определенного индекса.
//
// Первый аргумент указывает на массив. Второй аргумент идентифицирует индекс начального элемент массива.
//  Третий аргумент указывает сколько элементов вернуть.
db.companies.aggregate([
    { $match: { "founded_year": 2010 } },
    { $project: {
        _id: 0,
        name: 1,
        founded_year: 1,
        early_rounds: { $slice: [ "$funding_rounds", 1, 3 ] } }
    }
]).pretty()
```

#### 3.8.4. $size.
```js
// Оператор $size позволяет определять размер или длину массива.
//
// Первый аргумент указывает на массив. $size отдаст размер массива полю total_rounds.
db.companies.aggregate([
    { $match: { "founded_year": 2004 } },
    { $project: {
        _id: 0,
        name: 1,
        founded_year: 1,
        total_rounds: { $size: "$funding_rounds" } }
    }
]).pretty()
```

### 3.9. Аккумуляторы и $group.
```js
// Аккумуляторы
//
// Традиционно аккумуляторы были областью этапа с оператором $group, но так же доступны
// в этапах: $project, $addFields, $set, and $setWindowFields.

// $group
// Данный этап выполняет функцию, аналогичную SQL-команде GROUP BY. На этом этапе 
// мы можем сгруппировать значения из нескольких документов и выполнять с ними
// операции агрегации определенного типа.
```

#### 3.9.1. $avg.
```js
// Аккумулятор $avg позволяет вычислять среднее арифметическое опредленного поля.
//
// Вычислим среднее значение поля годовых трат в ТЦ по возрасту, отсортируем в порядке
// возрастания по возрасту и ограничим вывод первых 10 документов. 
db.Mall_Customers.aggregate([
  { $group: {
    _id: { age: "$Age" },
    avg_annual_income: { $avg: "$Annual Income (k$)"}
  } }, 
  { $sort: { _id: 1 } },
  { $limit: 10 }
]).pretty()
```

#### 3.9.2. $sum.
```js
// Аккумулятор $sum позволяет искать кол-во подходящих документов или складывать значения.
//
// Вычислим сумму выручки за отдельный день в году и кол-во продаж в этот день.
db.sales.aggregate([
    { $group: {
        _id: { day: { $dayOfYear: "$date"}, year: { $year: "$date" } },
        totalAmount: { $sum: { $multiply: [ "$price", "$quantity" ] } },
        count: { $sum: 1 } }
    }
])
```

### 3.10. Запись результатов конвейера агрегации в коллекцию.
```
Существует два этапа, $out и $merge, которые могут записывать документы,
полученные из конвейера агрегации, в коллекцию. Этап записи в коллекцию должен быть
последним этапом конвейера. $merge является предпочтительным этапом для выполнения записи в коллекцию.
```
[Ссылка на оф. документацию $merge](https://docs.mongodb.com/v5.0/reference/operator/aggregation/merge/#mongodb-pipeline-pipe.-merge)
```js
db.sales.aggregate( [
   { $match: { date: { $gte: new Date("2019-05-01"), $lt: new Date("2019-06-01") } } },
   { $group: { _id: { $dateToString: { format: "%Y-%m-%d", date: "$date" } }, totalqty: { $sum: "$quantity" } } },
   { $project: { _id: 0, salesDate: { $toDate: "$_id" }, totalqty: 1 } },
   { $merge : { into : "newDailySales201905", on: "salesDate" } }
] )
```
